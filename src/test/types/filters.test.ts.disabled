import { describe, it, expect } from 'vitest'
import type {
  FilterOption,
  AppointmentStatusFilter,
  SessionStatusFilter,
  FilterParams
} from '@/types/filters'
import {
  parseAppointmentStatusFilter,
  parseSessionStatusFilter
} from '@/types/filters'
import type { AppointmentStatus, SessionStatus } from '@prisma/client'

describe('Filter Types', () => {
  describe('FilterOption Generic Type', () => {
    it('should allow specific type or "ALL"', () => {
      const stringFilter: FilterOption<string> = 'ACTIVE'
      const allStringFilter: FilterOption<string> = 'ALL'
      const numberFilter: FilterOption<number> = 42
      const allNumberFilter: FilterOption<number> = 'ALL'

      expect(stringFilter).toBe('ACTIVE')
      expect(allStringFilter).toBe('ALL')
      expect(numberFilter).toBe(42)
      expect(allNumberFilter).toBe('ALL')
    })

    it('should work with enum types', () => {
      type StatusEnum = 'ACTIVE' | 'INACTIVE' | 'PENDING'
      const statusFilter: FilterOption<StatusEnum> = 'ACTIVE'
      const allStatusFilter: FilterOption<StatusEnum> = 'ALL'

      expect(statusFilter).toBe('ACTIVE')
      expect(allStatusFilter).toBe('ALL')
    })
  })

  describe('AppointmentStatusFilter Type', () => {
    it('should accept valid appointment statuses', () => {
      const scheduledFilter: AppointmentStatusFilter = 'SCHEDULED'
      const confirmedFilter: AppointmentStatusFilter = 'CONFIRMED'
      const inProgressFilter: AppointmentStatusFilter = 'IN_PROGRESS'
      const completedFilter: AppointmentStatusFilter = 'COMPLETED'
      const cancelledFilter: AppointmentStatusFilter = 'CANCELLED'
      const allFilter: AppointmentStatusFilter = 'ALL'

      expect(scheduledFilter).toBe('SCHEDULED')
      expect(confirmedFilter).toBe('CONFIRMED')
      expect(inProgressFilter).toBe('IN_PROGRESS')
      expect(completedFilter).toBe('COMPLETED')
      expect(cancelledFilter).toBe('CANCELLED')
      expect(allFilter).toBe('ALL')
    })

    it('should be compatible with AppointmentStatus enum', () => {
      const status: AppointmentStatus = 'SCHEDULED'
      const filter: AppointmentStatusFilter = status

      expect(filter).toBe('SCHEDULED')
    })
  })

  describe('SessionStatusFilter Type', () => {
    it('should accept valid session statuses', () => {
      const scheduledFilter: SessionStatusFilter = 'SCHEDULED'
      const inProgressFilter: SessionStatusFilter = 'IN_PROGRESS'
      const completedFilter: SessionStatusFilter = 'COMPLETED'
      const cancelledFilter: SessionStatusFilter = 'CANCELLED'
      const noShowFilter: SessionStatusFilter = 'NO_SHOW'
      const allFilter: SessionStatusFilter = 'ALL'

      expect(scheduledFilter).toBe('SCHEDULED')
      expect(inProgressFilter).toBe('IN_PROGRESS')
      expect(completedFilter).toBe('COMPLETED')
      expect(cancelledFilter).toBe('CANCELLED')
      expect(noShowFilter).toBe('NO_SHOW')
      expect(allFilter).toBe('ALL')
    })

    it('should be compatible with SessionStatus enum', () => {
      const status: SessionStatus = 'IN_PROGRESS'
      const filter: SessionStatusFilter = status

      expect(filter).toBe('IN_PROGRESS')
    })
  })

  describe('parseAppointmentStatusFilter Function', () => {
    it('should parse valid appointment status strings', () => {
      expect(parseAppointmentStatusFilter('SCHEDULED')).toBe('SCHEDULED')
      expect(parseAppointmentStatusFilter('CONFIRMED')).toBe('CONFIRMED')
      expect(parseAppointmentStatusFilter('IN_PROGRESS')).toBe('IN_PROGRESS')
      expect(parseAppointmentStatusFilter('COMPLETED')).toBe('COMPLETED')
      expect(parseAppointmentStatusFilter('CANCELLED')).toBe('CANCELLED')
    })

    it('should handle "ALL" filter correctly', () => {
      expect(parseAppointmentStatusFilter('ALL')).toBe('ALL')
    })

    it('should default to "ALL" for invalid status strings', () => {
      expect(parseAppointmentStatusFilter('INVALID_STATUS')).toBe('ALL')
      expect(parseAppointmentStatusFilter('invalid')).toBe('ALL')
      expect(parseAppointmentStatusFilter('scheduled')).toBe('ALL') // lowercase
      expect(parseAppointmentStatusFilter('')).toBe('ALL')
      expect(parseAppointmentStatusFilter('null')).toBe('ALL')
      expect(parseAppointmentStatusFilter('undefined')).toBe('ALL')
    })

    it('should be case sensitive', () => {
      expect(parseAppointmentStatusFilter('scheduled')).toBe('ALL')
      expect(parseAppointmentStatusFilter('Scheduled')).toBe('ALL')
      expect(parseAppointmentStatusFilter('SCHEDULED')).toBe('SCHEDULED')
    })

    it('should handle edge cases', () => {
      expect(parseAppointmentStatusFilter('ALL')).toBe('ALL')
      expect(parseAppointmentStatusFilter('all')).toBe('ALL') // Should default to ALL for lowercase
      expect(parseAppointmentStatusFilter(' SCHEDULED ')).toBe('ALL') // Spaces should make it invalid
      expect(parseAppointmentStatusFilter('123')).toBe('ALL')
      expect(parseAppointmentStatusFilter('!@#')).toBe('ALL')
    })

    it('should return correct type', () => {
      const result: AppointmentStatusFilter = parseAppointmentStatusFilter('SCHEDULED')
      expect(typeof result).toBe('string')
      expect(result).toBe('SCHEDULED')
    })
  })

  describe('parseSessionStatusFilter Function', () => {
    it('should parse valid session status strings', () => {
      expect(parseSessionStatusFilter('SCHEDULED')).toBe('SCHEDULED')
      expect(parseSessionStatusFilter('IN_PROGRESS')).toBe('IN_PROGRESS')
      expect(parseSessionStatusFilter('COMPLETED')).toBe('COMPLETED')
      expect(parseSessionStatusFilter('CANCELLED')).toBe('CANCELLED')
      expect(parseSessionStatusFilter('NO_SHOW')).toBe('NO_SHOW')
    })

    it('should handle "ALL" filter correctly', () => {
      expect(parseSessionStatusFilter('ALL')).toBe('ALL')
    })

    it('should default to "ALL" for invalid status strings', () => {
      expect(parseSessionStatusFilter('INVALID_STATUS')).toBe('ALL')
      expect(parseSessionStatusFilter('invalid')).toBe('ALL')
      expect(parseSessionStatusFilter('in_progress')).toBe('ALL') // lowercase
      expect(parseSessionStatusFilter('')).toBe('ALL')
      expect(parseSessionStatusFilter('null')).toBe('ALL')
      expect(parseSessionStatusFilter('undefined')).toBe('ALL')
    })

    it('should be case sensitive', () => {
      expect(parseSessionStatusFilter('completed')).toBe('ALL')
      expect(parseSessionStatusFilter('Completed')).toBe('ALL')
      expect(parseSessionStatusFilter('COMPLETED')).toBe('COMPLETED')
    })

    it('should handle edge cases', () => {
      expect(parseSessionStatusFilter('ALL')).toBe('ALL')
      expect(parseSessionStatusFilter('all')).toBe('ALL') // Should default to ALL for lowercase
      expect(parseSessionStatusFilter(' NO_SHOW ')).toBe('ALL') // Spaces should make it invalid
      expect(parseSessionStatusFilter('123')).toBe('ALL')
      expect(parseSessionStatusFilter('!@#')).toBe('ALL')
    })

    it('should return correct type', () => {
      const result: SessionStatusFilter = parseSessionStatusFilter('NO_SHOW')
      expect(typeof result).toBe('string')
      expect(result).toBe('NO_SHOW')
    })

    it('should handle session-specific statuses', () => {
      expect(parseSessionStatusFilter('NO_SHOW')).toBe('NO_SHOW')
      expect(parseSessionStatusFilter('CONFIRMED')).toBe('ALL') // Not valid for sessions
    })
  })

  describe('FilterParams Interface', () => {
    it('should define complete filter parameters structure', () => {
      const filterParams: FilterParams = {
        appointmentStatus: 'SCHEDULED',
        sessionStatus: 'IN_PROGRESS',
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        limit: 20,
        offset: 0,
        search: 'john',
        clientId: 'client-123',
        artistId: 'artist-456'
      }

      expect(filterParams.appointmentStatus).toBe('SCHEDULED')
      expect(filterParams.sessionStatus).toBe('IN_PROGRESS')
      expect(typeof filterParams.startDate).toBe('string')
      expect(typeof filterParams.endDate).toBe('string')
      expect(typeof filterParams.limit).toBe('number')
      expect(typeof filterParams.offset).toBe('number')
      expect(typeof filterParams.search).toBe('string')
      expect(typeof filterParams.clientId).toBe('string')
      expect(typeof filterParams.artistId).toBe('string')
    })

    it('should allow partial filter parameters', () => {
      const minimalParams: FilterParams = {
        limit: 10
      }

      const searchOnlyParams: FilterParams = {
        search: 'tattoo',
        appointmentStatus: 'ALL'
      }

      expect(minimalParams.limit).toBe(10)
      expect(minimalParams.appointmentStatus).toBeUndefined()
      expect(minimalParams.sessionStatus).toBeUndefined()

      expect(searchOnlyParams.search).toBe('tattoo')
      expect(searchOnlyParams.appointmentStatus).toBe('ALL')
      expect(searchOnlyParams.limit).toBeUndefined()
    })

    it('should allow "ALL" filter values', () => {
      const allFiltersParams: FilterParams = {
        appointmentStatus: 'ALL',
        sessionStatus: 'ALL'
      }

      expect(allFiltersParams.appointmentStatus).toBe('ALL')
      expect(allFiltersParams.sessionStatus).toBe('ALL')
    })

    it('should handle date filtering', () => {
      const dateFilterParams: FilterParams = {
        startDate: '2024-01-01T00:00:00Z',
        endDate: '2024-12-31T23:59:59Z'
      }

      expect(typeof dateFilterParams.startDate).toBe('string')
      expect(typeof dateFilterParams.endDate).toBe('string')
      expect(dateFilterParams.startDate).toContain('2024-01-01')
      expect(dateFilterParams.endDate).toContain('2024-12-31')
    })

    it('should handle pagination parameters', () => {
      const paginationParams: FilterParams = {
        limit: 25,
        offset: 50
      }

      expect(paginationParams.limit).toBe(25)
      expect(paginationParams.offset).toBe(50)
      expect(typeof paginationParams.limit).toBe('number')
      expect(typeof paginationParams.offset).toBe('number')
    })

    it('should handle search and ID filtering', () => {
      const searchParams: FilterParams = {
        search: 'dragon tattoo',
        clientId: 'client-123',
        artistId: 'artist-456'
      }

      expect(searchParams.search).toBe('dragon tattoo')
      expect(searchParams.clientId).toBe('client-123')
      expect(searchParams.artistId).toBe('artist-456')
    })
  })

  describe('Internal Helper Functions', () => {
    // These test the internal validation functions through the public API
    it('should validate appointment status correctly', () => {
      const validStatuses = ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']
      const invalidStatuses = ['INVALID', 'scheduled', 'Completed', 'NO_SHOW', '']

      validStatuses.forEach(status => {
        expect(parseAppointmentStatusFilter(status)).toBe(status)
      })

      invalidStatuses.forEach(status => {
        expect(parseAppointmentStatusFilter(status)).toBe('ALL')
      })
    })

    it('should validate session status correctly', () => {
      const validStatuses = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'NO_SHOW']
      const invalidStatuses = ['INVALID', 'scheduled', 'Completed', 'CONFIRMED', '']

      validStatuses.forEach(status => {
        expect(parseSessionStatusFilter(status)).toBe(status)
      })

      invalidStatuses.forEach(status => {
        expect(parseSessionStatusFilter(status)).toBe('ALL')
      })
    })

    it('should handle overlapping statuses correctly', () => {
      // These statuses exist in both enums
      const overlappingStatuses = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']

      overlappingStatuses.forEach(status => {
        expect(parseAppointmentStatusFilter(status)).toBe(status)
        expect(parseSessionStatusFilter(status)).toBe(status)
      })

      // These are unique to each enum
      expect(parseAppointmentStatusFilter('CONFIRMED')).toBe('CONFIRMED')
      expect(parseSessionStatusFilter('CONFIRMED')).toBe('ALL')

      expect(parseSessionStatusFilter('NO_SHOW')).toBe('NO_SHOW')
      expect(parseAppointmentStatusFilter('NO_SHOW')).toBe('ALL')
    })
  })

  describe('Type Safety and Compatibility', () => {
    it('should maintain type safety with enum values', () => {
      const appointmentStatus: AppointmentStatus = 'SCHEDULED'
      const sessionStatus: SessionStatus = 'COMPLETED'

      const appointmentFilter: AppointmentStatusFilter = appointmentStatus
      const sessionFilter: SessionStatusFilter = sessionStatus

      expect(appointmentFilter).toBe('SCHEDULED')
      expect(sessionFilter).toBe('COMPLETED')
    })

    it('should work with type guards', () => {
      const checkAppointmentFilter = (filter: AppointmentStatusFilter): boolean => {
        if (filter === 'ALL') return true
        return ['SCHEDULED', 'CONFIRMED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'].includes(filter)
      }

      const checkSessionFilter = (filter: SessionStatusFilter): boolean => {
        if (filter === 'ALL') return true
        return ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'NO_SHOW'].includes(filter)
      }

      expect(checkAppointmentFilter('SCHEDULED')).toBe(true)
      expect(checkAppointmentFilter('ALL')).toBe(true)
      expect(checkSessionFilter('NO_SHOW')).toBe(true)
      expect(checkSessionFilter('ALL')).toBe(true)
    })

    it('should handle filter combinations in realistic scenarios', () => {
      const buildAppointmentFilters = (
        status?: string,
        search?: string
      ): FilterParams => ({
        appointmentStatus: status ? parseAppointmentStatusFilter(status) : undefined,
        search: search || undefined,
        limit: 20,
        offset: 0
      })

      const filters1 = buildAppointmentFilters('SCHEDULED', 'john')
      const filters2 = buildAppointmentFilters('INVALID_STATUS', 'jane')
      const filters3 = buildAppointmentFilters(undefined, 'search only')

      expect(filters1.appointmentStatus).toBe('SCHEDULED')
      expect(filters1.search).toBe('john')

      expect(filters2.appointmentStatus).toBe('ALL')
      expect(filters2.search).toBe('jane')

      expect(filters3.appointmentStatus).toBeUndefined()
      expect(filters3.search).toBe('search only')
    })

    it('should handle empty and null values gracefully', () => {
      const emptyParams: FilterParams = {}
      const nullishParams: FilterParams = {
        appointmentStatus: undefined,
        sessionStatus: undefined,
        startDate: undefined,
        endDate: undefined,
        search: undefined,
        clientId: undefined,
        artistId: undefined,
        limit: undefined,
        offset: undefined
      }

      expect(Object.keys(emptyParams)).toHaveLength(0)
      expect(Object.values(nullishParams).every(value => value === undefined)).toBe(true)
    })
  })

  describe('Edge Cases and Error Handling', () => {
    it('should handle special characters in filter parsing', () => {
      const specialChars = ['!@#$%', '   ', '\n\t', '123abc', 'SCHEDULED!', ' SCHEDULED']

      specialChars.forEach(char => {
        expect(parseAppointmentStatusFilter(char)).toBe('ALL')
        expect(parseSessionStatusFilter(char)).toBe('ALL')
      })
    })

    it('should handle extremely long strings', () => {
      const longString = 'A'.repeat(1000)
      expect(parseAppointmentStatusFilter(longString)).toBe('ALL')
      expect(parseSessionStatusFilter(longString)).toBe('ALL')
    })

    it('should handle Unicode characters', () => {
      const unicodeStrings = ['SCHËDULED', '调度的', 'СПЛАНИРОВАНО', '🗓️']

      unicodeStrings.forEach(str => {
        expect(parseAppointmentStatusFilter(str)).toBe('ALL')
        expect(parseSessionStatusFilter(str)).toBe('ALL')
      })
    })

    it('should handle numbers and mixed types', () => {
      const mixedInputs = ['123', '0', '-1', '1.5', 'SCHEDULED123', '123SCHEDULED']

      mixedInputs.forEach(input => {
        expect(parseAppointmentStatusFilter(input)).toBe('ALL')
        expect(parseSessionStatusFilter(input)).toBe('ALL')
      })
    })

    it('should maintain consistency across multiple calls', () => {
      const testValue = 'SCHEDULED'
      const calls = Array(100).fill(testValue).map(val => parseAppointmentStatusFilter(val))

      expect(calls.every(result => result === 'SCHEDULED')).toBe(true)
    })

    it('should handle boundary conditions', () => {
      // Test the exact boundary of valid enum values
      const lastValidAppointment = 'CANCELLED'
      const lastValidSession = 'NO_SHOW'

      expect(parseAppointmentStatusFilter(lastValidAppointment)).toBe('CANCELLED')
      expect(parseSessionStatusFilter(lastValidSession)).toBe('NO_SHOW')

      // Test values just outside the boundary
      expect(parseAppointmentStatusFilter('NO_SHOW')).toBe('ALL')
      expect(parseSessionStatusFilter('CONFIRMED')).toBe('ALL')
    })
  })
})